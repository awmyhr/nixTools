#!/usr/bin/python2 -tt
# -*- coding: utf-8 -*-
# ^^-- use utf-8 strings by default
#-- NOTE: Tabs and spaces do NOT mix!! '-tt' will flag violations as an error.
#===============================================================================
'''
    :program:`pkg_mgr_facts`
    ============================================================

    In addition to the options listed in help output, :program:`pkg_mgr_facts` includes
    the following 'hidden' options:

    .. option:: --help-rest

        Output usage information in Sphinx/reST-style markup.

    .. option:: --debug

        Output debug-level information.

    :synopsis: Lists number of packages installed from each repo.

    :copyright: 2016 awmyhr
    :license: Apache-2.0

    .. codeauthor:: awmyhr <awmyhr@gmail.com>
'''
#===============================================================================
#-- Standard Imports
#-- NOTE: See __future__ documentation at https://docs.python.org/2/library/__future__.html
#--       This allows us to write Python 3 code for older version.
from __future__ import absolute_import  #: Require parens to group imports PEP-0328
from __future__ import division         #: Enable 3.x True Division PEP-0238
from __future__ import with_statement   #: Clean up some uses of try/except PEP--343
#-- These may break 2.5 compatibility
from __future__ import print_function   #: Makes print a function, not a statement PEP-3105
from __future__ import unicode_literals #: Introduce bytes type for older strings PEP-3112
#-- NOTE: We use optparse for compatibility with python < 2.7 as
#--       argparse wasn't standard until 2.7 (2.7 deprecates optparse)
#--       As of 20161212 the template is coded for optparse only
import optparse     #: pylint: disable=deprecated-module
import logging      #: Python's standard logging facilities
import os           #: Misc. OS interfaces
import sys          #: System-specific parameters & functions
import collections
# import traceback    #: Print/retrieve a stack traceback
#==============================================================================
#-- Third Party Imports
#==============================================================================
#-- Require a minimum Python version
if sys.version_info <= (2, 6):
    sys.exit("Minimum Python version: 2.6")
#-- NOTE: default Python versions:
#--       RHEL4    2.3.4
#--       RHEL5    2.4.3
#--       RHEL6.0  2.6.5
#--       RHEL6.1+ 2.6.6
#--       REHL7    2.7.5
#-- Recent Fedora versions (24/25) stay current on 2.7 (2.7.12 as of 20161212)
#==============================================================================
#==============================================================================
#-- Application Library Imports
#==============================================================================
#-- Variables which are meta for the script should be dunders (__varname__)
#-- TODO: Update meta vars
__version__ = '2.1.1' #: current version
__revised__ = '20190417-161537' #: date of most recent revision
__contact__ = 'awmyhr <awmyhr@gmail.com>' #: primary contact for support/?'s
__synopsis__ = 'Discover information about installed packages.'
__description__ = '''This will try to discover information about packages installed on a system,
the package manager, and subscription service (if any). Primarily intended
to capture package counts from repositories, it can also capture detailed
package information if desired.
'''
#------------------------------------------------------------------------------
#-- The following few variables should be relatively static over life of script
__author__ = ['awmyhr <awmyhr@gmail.com>'] #: coder(s) of script
__created__ = '2016-11-16'               #: date script originlly created
__copyright__ = '2016 awmyhr' #: Copyright short name
__license__ = 'Apache-2.0'
__gnu_version__ = False #: If True print GNU version string (which includes copyright/license)
__cononical_name__ = 'pkg_mgr_facts' #: static name, *NOT* os.path.basename(sys.argv[0])
__project_name__ = 'nixTools from *NIXLand'  #: name of overall project, if needed
__project_home__ = 'https://github.com/awmyhr/nixTools'  #: where to find source/documentation
__template_version__ = '2.1.0'  #: version of template file used
#-- We are not using this variable for now.
__docformat__ = 'reStructuredText en'       #: attempted style for documentation
__basename__ = os.path.basename(sys.argv[0]) #: name script run as
#------------------------------------------------------------------------------
#-- Flags
__logger_file_set__ = False #: If a file setup for logger
__require_root__ = False    #: Does script require root
#------------------------------------------------------------------------------
#-- Load in environment variables, or set defaults
__default_dsf__ = os.getenv('DEFAULT_TIMESTAMP') if 'DEFAULT_TIMESTAMP' in os.environ else "%Y%m%d-%H%M%S"
__logger_dsf__ = os.getenv('LOGGER_DSF') if 'LOGGER_DSF' in os.environ else __default_dsf__
__backup_dsf__ = os.getenv('BACKUP_DSF') if 'BACKUP_DSF' in os.environ else __default_dsf__
__logger_file__ = os.getenv('LOGGER_FILE') if 'LOGGER_FILE' in os.environ else None
__logger_lvl__ = os.getenv('LOGGER_LVL') if 'LOGGER_LVL' in os.environ else 'info'

EXIT_STATUS = None
#==============================================================================
class _ModOptionParser(optparse.OptionParser):
    ''' By default format_epilog() strips newlines, we don't want that,
        so we override.
    '''

    def format_epilog(self, formatter):
        ''' We'll preformat the epilog in the decleration, just pass it through '''
        return self.epilog


#==============================================================================
class _ReSTHelpFormatter(optparse.HelpFormatter):
    ''' Format help for Sphinx/ReST output.

    NOTE: All over-ridden methods started life as copy'n'paste from original's
          source code.

    '''

    def __init__(self, indent_increment=0, max_help_position=4, width=80, short_first=0):
        optparse.HelpFormatter.__init__(self, indent_increment,
                                        max_help_position, width, short_first
                                       )

    def format_usage(self, usage):
        retval = ['%s\n' % ('=-'[self.level] * len(__cononical_name__))]
        retval.append('%s\n' % (__cononical_name__))
        retval.append('%s\n\n' % ('=-'[self.level] * len(__cononical_name__)))
        retval.append('%s' % self.format_heading('Synopsis'))
        retval.append('**%s** %s\n\n' % (__cononical_name__, usage))
        return ''.join(retval)

    def format_heading(self, heading):
        return '%s\n%s\n\n' % (heading, '--'[self.level] * len(heading))

    def format_description(self, description):
        if description:
            retval = ['%s' % self.format_heading('Description')]
            retval.append('%s\n' % self._format_text(description))
            return ''.join(retval)
        return ''

    def format_option(self, option):
        opts = self.option_strings[option]
        retval = ['.. option:: %s\n\n' % opts]
        if option.help:
            # help_text = self.expand_default(option)
            # help_lines = textwrap.wrap(help_text, self.help_width)
            retval.append('%4s%s\n\n' % ('', self.expand_default(option)))
            # retval.extend(['%4s%s\n' % ('', line)
            #                for line in help_lines[1:]])
        elif opts[-1] != '\n':
            retval.append('\n')
        return ''.join(retval)

    def format_option_strings(self, option):
        ''' Return a comma-separated list of option strings & metavariables. '''
        if option.takes_value():
            metavar = option.metavar or option.dest.upper()
            short_opts = ['%s <%s>' % (sopt, metavar)
                          for sopt in option._short_opts] #: pylint: disable=protected-access
                                                          #: We're over-riding the default
                                                          #:    method, keeping most the code.
                                                          #:    Not sure how else we'd do this.
            long_opts = ['%s=<%s>' % (lopt, metavar)
                         for lopt in option._long_opts]   #: pylint: disable=protected-access
        else:
            short_opts = option._short_opts               #: pylint: disable=protected-access
            long_opts = option._long_opts                 #: pylint: disable=protected-access

        if self.short_first:
            opts = short_opts + long_opts
        else:
            opts = long_opts + short_opts

        return ', '.join(opts)


#==============================================================================
def timestamp(time_format=None):
    ''' Return date in specified format

    Args:
        time_format (str): Format string for timestamp. Compatible w/'date'.

    Returns:
        The formatted timestamp as a string.

    '''
    if 'logger' in globals():
        logger.debug('Entering Function: %s', sys._getframe().f_code.co_name) #: pylint: disable=protected-access
    import time
    if time_format is None:
        time_format = __default_dsf__
    return time.strftime(time_format.strip('+'))


#==============================================================================
def CLILogger(debug=False): #: pylint: disable=invalid-name
    ''' Set up Python's Logging

    Args:
        debug (boolean): Debug flag.

    Returns:
        The logging object.

    '''
    new_logger = logging.getLogger(__name__)
    new_logger.setLevel(logging.DEBUG)

    if debug:
        level = logging.DEBUG
        formatter = logging.Formatter('%(asctime)s %(levelname)-8s %(message)s',
                                      __logger_dsf__
                                     )
    else:
        if __logger_lvl__.isdigit():
            if int(__logger_lvl__) > 49:
                level = logging.CRITICAL
            elif int(__logger_lvl__) < 10:
                level = logging.NOTSET
            else:
                level = (int(__logger_lvl__)) //10 * 10
        else:
            level = logging.getLevelName(__logger_lvl__.upper())
        #-- Yes, we are going to ignore unknown values by setting to INFO
        if isinstance(level, str) and level.startswith('Level'):
            level = logging.INFO
        formatter = logging.Formatter('%(message)s')

    #-- Console output
    console = logging.StreamHandler()
    console.setLevel(level)
    console.setFormatter(formatter)
    new_logger.addHandler(console)

    #-- File output
    if __logger_file__:
        if os.path.isfile(__logger_file__):
            os.rename(__logger_file__, '%s.%s' % (__logger_file__, timestamp(__backup_dsf__)))
        #: NOTE: In Python >= 2.6 normally I give FileHandler 'delay="true"'
        logfile = logging.FileHandler(__logger_file__)
        logfile.setLevel(logging.DEBUG)
        formatter = logging.Formatter(
            '%(asctime)s.%(msecs)d:%(levelno)s:%(name)s.%(funcName)s:%(lineno)d:%(message)s',
            __logger_dsf__
            )
        logfile.setFormatter(formatter)
        new_logger.addHandler(logfile)
        global __logger_file_set__ #: pylint: disable=global-statement
        __logger_file_set__ = True

    import platform #: Easily get platforms identifying info
    new_logger.debug('Version:   %s (%s) %s', __cononical_name__, __project_name__, __version__)
    new_logger.debug('Created:   %s / Revised: %s', __created__, __revised__)
    new_logger.debug('Abs Path:  %s', os.path.abspath(sys.argv[0]))
    new_logger.debug('Full Args: %s', ' '.join(sys.argv[:]))
    new_logger.debug('Python:    %s (%s)', sys.executable, platform.python_version())
    new_logger.debug('Coder(s):  %s', __author__)
    new_logger.debug('Contact:   %s', __contact__)
    new_logger.debug('Project Home: %s', __project_home__)
    new_logger.debug('Template Version: %s', __template_version__)
    new_logger.debug('System:    %s', platform.system_alias(platform.system(),
                                                            platform.release(),
                                                            platform.version()
                                                           )
                    )
    new_logger.debug('Platform:  %s', platform.platform())
    new_logger.debug('Hostname:  %s', platform.node())
    new_logger.debug('[res]uid:  %s/%s/', os.getuid(), os.geteuid())
    new_logger.debug('PID/PPID:  %s/%s', os.getpid(), os.getppid())
    if options._options is not None:                             #: pylint: disable=protected-access
        new_logger.debug('Parsed Options: %s', options._options) #: pylint: disable=protected-access
    if debug:
        print('\n----- start -----\n')

    return new_logger


#==============================================================================
class CLIOptions(object):
    ''' Parse the options and put them into an object

        Returns:
            A CLIOptions object.

    '''

    _options = None
    _arguments = None

    def __init__(self, args=None):
        if self._options is not None:
            raise ValueError('CLIOptions already initialized.')
        else:
            (self._options, self._arguments) = self._parse_args(args)

    @property
    def args(self):
        ''' Class property '''
        if self._arguments is not None:
            return self._arguments
        return None

    @property
    def key(self):
        ''' Class property '''
        if self._options is not None:
            return self._options.key
        return None

    @key.setter
    def key(self, value):
        ''' Property setter '''
        if self._options is not None:
            self._options.key = value
            return True
        return False

    @property
    def debug(self):
        ''' Class property '''
        if self._options is not None:
            return self._options.debug
        return None

    @property
    def ansible_called(self):
        ''' Class property '''
        return bool(__basename__.startswith('ansible_module'))

    @property
    def shell(self):
        ''' Class property '''
        if self._options is not None:
            return self._options.shell
        return None

    @property
    def yaml(self):
        ''' Class property '''
        if self._options is not None:
            return self._options.yaml
        return None

    @property
    def json(self):
        ''' Class property '''
        if self._options is not None:
            return self._options.json
        return None

    @property
    def rhsm(self):
        ''' Class property '''
        if self._options is not None:
            return self._options.rhsm
        return None

    @property
    def all(self):
        ''' Class property '''
        if self._options is not None:
            return self._options.all
        return True

    @property
    def enabled(self):
        ''' Class property '''
        if self._options is not None:
            return self._options.enabled
        return False

    @property
    def disabled(self):
        ''' Class property '''
        if self._options is not None:
            return self._options.disabled
        return False

    @property
    def inc_pkgs(self):
        ''' Class property '''
        if self._options is not None:
            return self._options.inc_pkgs
        return False

    @inc_pkgs.setter
    def inc_pkgs(self, value):
        ''' Property setter '''
        if self._options is not None:
            self._options.inc_pkgs = value
            return True
        return False

    def _parse_args(self, args):
        #-- Parse Options (rely on OptionsParser's exception handling)
        description_string = __synopsis__
        epilog_string = ('\n%s\n\n'
                         'Created: %s  Contact: %s\n'
                         'Revised: %s  Version: %s\n'
                         '%s, part of %s. Project home: %s\n'
                        ) % (__description__,
                             __created__, __contact__,
                             __revised__, __version__,
                             __cononical_name__, __project_name__, __project_home__
                            )
        usage_string = '%s [options]' % (__basename__)
        version_string = '%s (%s) %s' % (__cononical_name__, __project_name__, __version__)
        if __gnu_version__:
            version_string += '\nCopyright %s\nLicense %s\n' % (__copyright__, __license__)
        parser = _ModOptionParser(version=version_string, usage=usage_string,
                                  description=description_string, epilog=epilog_string
                                 )
        self.parser = parser
        #-- Put visible options here (don't forget @property if needed).
        parser.add_option('-e', '--enabled', dest='enabled', action='store_true',
                          help='Enabled repos only.', default=False
                         )
        parser.add_option('-d', '--disabled', dest='disabled', action='store_true',
                          help='Disabled repos only.', default=False
                         )
        parser.add_option('-k', '--key', dest='key', type='string', default='custom',
                          help='key for fact tree'
                         )
        parser.add_option('--include-packages', dest='inc_pkgs', action='store_true',
                          help='Include detailed package list', default=False)

        #-- Output group options.
        group = optparse.OptionGroup(parser, 'Output Options',
                                     'Select an alternative output format, if desired. '
                                     '(Only one).'
                                    )
        group.add_option('--shell', dest='shell', action='store_true',
                         help='output shell variables', default=False
                        )
        group.add_option('--json', dest='json', action='store_true',
                         help='output json snippet', default=False
                        )
        group.add_option('--yaml', dest='yaml', action='store_true',
                         help='output yaml snippet', default=False
                        )
        group.add_option('--rhsm', dest='rhsm', action='store_true',
                         help='output rhsm snippet', default=False
                        )
        parser.add_option_group(group)
        #-- Put hidden options here (don't forget @property if needed).
        parser.add_option('-a', '--all', dest='all', action='store_true',
                          help=optparse.SUPPRESS_HELP, default=True
                         )
        parser.add_option('--help-rest', dest='helprest', action='store_true',
                          help=optparse.SUPPRESS_HELP, default=False
                         )
        parser.add_option('--debug', dest='debug', action='store_true',
                          help=optparse.SUPPRESS_HELP, default=False
                         )

        parsed_opts, parsed_args = parser.parse_args(args)
        if parsed_opts.helprest:
            parser.formatter = _ReSTHelpFormatter()
            parser.usage = '[*options*]'            #: pylint: disable=attribute-defined-outside-init
                                                    #: Not yet sure of a better way to do this...
            parser.description = __description__    #: pylint: disable=attribute-defined-outside-init
            parser.epilog = ('\nAuthor\n------\n\n'
                             '%s\n'
                            ) % ('; '.join(__author__))
            parser.print_help()
            sys.exit(os.EX_OK)
        #-- Put any option validation here...
        if parsed_opts.shell and parsed_opts.json:
            parser.error('--shell, --json and --yaml are mutually exclusive')
        if parsed_opts.shell and parsed_opts.yaml:
            parser.error('--shell, --json and --yaml are mutually exclusive')
        if parsed_opts.yaml and parsed_opts.json:
            parser.error('--shell, --json and --yaml are mutually exclusive')

        if parsed_opts.enabled and parsed_opts.disabled:
            parser.error('Options -e and -d are mutually exclusive.')
        elif parsed_opts.enabled or parsed_opts.disabled:
            parsed_opts.all = False

        return parsed_opts, parsed_args


#==============================================================================
def dicttree():
    ''' Return a defaultdict tree.

    Returns:
        Returns an empty dictionary.

    '''
    logger.debug('Entering Function: %s', sys._getframe().f_code.co_name) #: pylint: disable=protected-access
    from collections import defaultdict #: easily build an empty dictionary
    tree = lambda: defaultdict(tree)
    return tree()


#==============================================================================
def flatten(_dict, parent_key='', sep='.'):
    '''
        Originally stolen from: https://stackoverflow.com/a/6027615
    '''
    items = []
    for _key, _value in _dict.items():
        if _key is None:
            _key = 'None'
        _key = _key.replace('.', '_')
        _key = _key.replace(' ', '_')
        new_key = parent_key + sep + _key if parent_key else _key
        if isinstance(_value, collections.MutableMapping):
            items.extend(flatten(_value, new_key, sep=sep).items())
        else:
            items.append((new_key, _value))
    return dict(items)

#==============================================================================
def output_rhsm(facts, key=None):
    ''' Output a dictionary in RHSM fact file format (slightly modified json) '''
    logger.debug('Entering Function: %s', sys._getframe().f_code.co_name) #: pylint: disable=protected-access
    if key is not None:
        facts = {key: facts}
    facts = flatten(facts)
    print('{')
    for _key, _value in facts.items():
        if _value is None:
            continue
        print('  "%s":"%s",' % (_key, _value))
    print('  "%s._date":"%s"' % (key, timestamp()))
    print('}')
    return True


#==============================================================================
def output_json(facts, key=None):
    ''' Output a dictionary in json '''
    logger.debug('Entering Function: %s', sys._getframe().f_code.co_name) #: pylint: disable=protected-access
    if key is not None:
        facts = {key: facts}

    try:
        import json
        print(json.dumps(facts, sort_keys=True, indent=4))
    except ImportError:
        raise ImportError('Error: Python json module requried.')

    return True


#==============================================================================
def output_yaml(facts, key=None):
    ''' Output a dictionary in yaml '''
    logger.debug('Entering Function: %s', sys._getframe().f_code.co_name) #: pylint: disable=protected-access
    if key is not None:
        facts = {key: facts}

    try:
        import yaml
        from yaml.representer import Representer
        from collections import defaultdict
        yaml.add_representer(defaultdict, Representer.represent_dict)
        print(yaml.dump(facts, default_flow_style=False))
    except ImportError:
        raise ImportError('Error: Python yaml module requried.')

    return True


#==============================================================================
def output_shell(facts):
    ''' Output a dictionary as shell variables '''
    logger.debug('Entering Function: %s', sys._getframe().f_code.co_name) #: pylint: disable=protected-access
    print("PACKAGES_RAW=%s" % facts['packages_raw']['count'])
    print("PACKAGES_MANAGED=%s" % facts['packages_managed']['count'])
    count = 0
    for repoid, repoinfo in sorted(facts['packages_managed']['repository_list'].iteritems()):
        if repoinfo['count'] == 0:
            continue
        if repoid is None:
            print("REPO_NONE_COUNT=%s" % repoinfo['count'])
        elif repoinfo['isenabled'] and (options.all or options.enabled):
            print("REPO_%s_NAME=%s" % (count, repoid))
            print("REPO_%s_COUNT=%s" % (count, repoinfo['count']))
            print("REPO_%s_ENABLED=%s" % (count, repoinfo['isenabled']))
            count += 1
        elif not repoinfo['isenabled'] and (options.all or options.disabled):
            print("REPO_%s_NAME=%s" % (count, repoid))
            print("REPO_%s_COUNT=%s" % (count, repoinfo['count']))
            print("REPO_%s_ENABLED=%s" % (count, repoinfo['isenabled']))
            count += 1
    return True


#==============================================================================
def output_console(facts):
    ''' Output a dictionary to the console '''
    logger.debug('Entering Function: %s', sys._getframe().f_code.co_name) #: pylint: disable=protected-access
    print('%+6s\tTotal raw packages' % facts['packages_raw']['count'])
    print('%+6s\tTotal managed packages' % facts['packages_managed']['count'])
    for repoid, repoinfo in sorted(facts['packages_managed']['repository_list'].iteritems()):
        if repoinfo['count'] == 0:
            continue
        if repoid is None:
            print('%+6s\tPackages have no repo info' % repoinfo['count'])
        elif repoinfo['isenabled'] and (options.all or options.enabled):
            print('%+6s\t%s [enabled]' % (repoinfo['count'], repoid))
        elif not repoinfo['isenabled'] and (options.all or options.disabled):
            print('%+6s\t%s [disabled]' % (repoinfo['count'], repoid))
    return True


#==============================================================================
def get_subscription_service():
    ''' Try to discover subscription service and return some facts '''
    logger.debug('Entering Function: %s', sys._getframe().f_code.co_name) #: pylint: disable=protected-access

    results = {'server': None, 'type': None}
    if results['type'] is None:
        try:
            sys.path.append('/usr/share/rhn')
            import up2date_client.up2dateAuth
            import up2date_client.config
            import urlparse
            config = up2date_client.config.initUp2dateConfig()
            #-- NOTE: the official rhn_register Ansible module considers this good
            #         enough 'proof' that a system is registered:
            if os.access(config['systemIdPath'], os.R_OK):
                xml_string = up2date_client.up2dateAuth.getSystemId()
                if 'RHSM' not in xml_string:
                    results['server'] = urlparse.urlsplit(config['serverURL'])[1]
                    results['type'] = 'RHN'
        except ImportError:
            pass
    if results['type'] is None:
        try:
            import rhsm.config
            import subscription_manager.identity
            ident = subscription_manager.identity.Identity()
            if ident.is_valid:
                config = rhsm.config.initConfig()
                results['server'] = config.get('server', 'hostname')
                results['type'] = 'RHSM'
        except ImportError:
            pass

    return results


#===============================================================================
def get_package_manager():
    ''' Determine package manager '''
    logger.debug('Entering Function: %s', sys._getframe().f_code.co_name) #: pylint: disable=protected-access

    #-- NOTE: it is possible a system may have more then one (example: on Fedora
    #         yum is a symlink to dnf). Ensure the 'true' one comes first in the
    #         list.
    #         I originally found list in Ansible's 'pkg_mgr' fact library, but have
    #         since modified it.
    pkg_mgrs = {
        '/usr/bin/dnf': 'dnf',
        '/usr/bin/yum': 'yum',
        '/usr/bin/apt-get': 'apt',
        '/usr/bin/zypper': 'zypper',
        '/usr/sbin/urpmi': 'urpmi',
        '/usr/bin/pacman': 'pacman',
        '/bin/opkg': 'opkg',
        '/usr/pkg/bin/pkgin': 'pkgin',
        '/opt/local/bin/pkgin': 'pkgin',
        '/opt/tools/bin/pkgin': 'pkgin',
        '/usr/local/bin/brew': 'homebrew',
        '/opt/local/bin/port': 'macports',
        '/sbin/apk': 'apk',
        '/usr/sbin/pkg': 'pkgng',
        '/usr/sbin/swlist': 'HP-UX',
        '/usr/bin/emerge': 'portage',
        '/usr/sbin/pkgadd': 'svr4pkg',
        '/usr/bin/pkg': 'pkg5',
        '/usr/bin/xbps-install': 'xbps',
        '/usr/local/sbin/pkg': 'pkgng',
        '/usr/bin/swupd': 'swupd',
        '/usr/sbin/sorcery': 'sorcery',
        '/usr/bin/rpm-ostree': 'atomic_container',
    }

    for pkg_mgr in pkg_mgrs:
        if os.path.exists(pkg_mgr):
            return pkg_mgrs[pkg_mgr]

    return None


#===============================================================================
def get_package_format():
    ''' Determine package manager '''
    logger.debug('Entering Function: %s', sys._getframe().f_code.co_name) #: pylint: disable=protected-access

    #-- NOTE: it is possible a system may have more then one. Ensure the 'true'
    #         one comes first in the list.
    #         Obviously this needs a *ton* of work.
    pkg_formats = {
        '/bin/rpm': 'rpm',
        '/usr/bin/rpm': 'rpm',
    }

    for pkg_format in pkg_formats:
        if os.path.exists(pkg_format):
            return pkg_formats[pkg_format]

    return None


#===============================================================================
def get_raw_packages_rpm():
    """ Quick'n'Dirty 'rpm -qa | wc -l' """
    logger.debug('Entering Function: %s', sys._getframe().f_code.co_name) #: pylint: disable=protected-access
    results = {
        'count': 0,
        'packages': []
    }

    try:
        import rpm
        for pkg in rpm.TransactionSet().dbMatch():
            if options.inc_pkgs:
                results['packages'].append({
                    'name': pkg['name'],
                    'version': pkg['version'],
                    'release': pkg['release'],
                    'platform': pkg['platform'],
                    'arch': pkg['arch'],
                    'vendor': pkg['vendor'],
                    'distribution': pkg['distribution'],
                    'os': pkg['os']
                })
            results['count'] += 1
    except ImportError:
        pass

    return results


#===============================================================================
def get_packages_yum():
    """ Builds dictionary of repos with counts & enabled status """
    logger.debug('Entering Function: %s', sys._getframe().f_code.co_name) #: pylint: disable=protected-access
    repos = dicttree()
    count = 0

    try:
        import yum

        yumb = yum.YumBase()
        #-- Suppress spurious messages
        yumb.preconf.debuglevel = 0
        yumb.preconf.errorlevel = 0
        #-- Do not try to update cache if euid not root
        yumb.conf.cache = os.geteuid() != 0

        repos['_localinstall']['count'] = 0
        repos['_localinstall']['name'] = 'yum localinstall'
        repos['_localinstall']['baseurl'] = '<none>'
        repos['_localinstall']['isenabled'] = False
        repos['_localinstall']['exists'] = False
        repos['_localinstall']['packages'] = []

        for pkg in yumb.rpmdb.returnPackages():
            repoid = pkg.yumdb_info.get('from_repo')
            try:
                if repoid.startswith('/'):
                    repos['_localinstall']['count'] += 1
                    if options.inc_pkgs:
                        repos['_localinstall']['packages'].append({
                            'name': pkg['name'],
                            'version': pkg['version'],
                            'release': pkg['release'],
                            'platform': pkg['platform'],
                            'arch': pkg['arch'],
                            'vendor': pkg['vendor'],
                            'distribution': pkg['distribution'],
                            'os': pkg['os']
                        })
                    continue
            except:
                pass
            if repoid in repos:
                repos[repoid]['count'] += 1
            else:
                repos[repoid]['count'] = 1
                repos[repoid]['packages'] = []
                try:
                    repos[repoid]['baseurl'] = yumb.repos.getRepo(repoid).baseurl
                    repos[repoid]['name'] = yumb.repos.getRepo(repoid).name
                    repos[repoid]['isenabled'] = yumb.repos.getRepo(repoid).isEnabled()
                    repos[repoid]['exists'] = True
                except:
                    repos[repoid]['baseurl'] = '<unknown>'
                    repos[repoid]['name'] = '<unknown>'
                    repos[repoid]['isenabled'] = False
                    repos[repoid]['exists'] = False
            if options.inc_pkgs:
                repos[repoid]['packages'].append({
                    'name': pkg['name'],
                    'version': pkg['version'],
                    'release': pkg['release'],
                    'platform': pkg['platform'],
                    'arch': pkg['arch'],
                    'vendor': pkg['vendor'],
                    'distribution': pkg['distribution'],
                    'os': pkg['os']
                })
        count = len(yumb.rpmdb.returnPackages())
    except ImportError:
        pass

    return {'repository_list': repos, 'count': count}


#==============================================================================
def get_packages_dnf():
    """ Builds dictionary of repos with counts & enabled status """
    logger.debug('Entering Function: %s', sys._getframe().f_code.co_name) #: pylint: disable=protected-access
    repos = dicttree()
    count = -1

    return {'repository_list': repos, 'count': count}


#==============================================================================
def main():
    ''' This is where the action takes place
        We expect options and logger to be global
    '''
    logger.debug('Starting main()')
    if options.ansible_called:
        from ansible.module_utils.basic import AnsibleModule
        module = AnsibleModule(
            argument_spec=dict(
                enabled=dict(default=True, type='bool'),
                include_packages=dict(default=False, type='bool'),
                key=dict(required=False)
            )
        )
        if module.params['key']:
            options.key = module.params['key']
        if module.params['include_packages']:
            options.inc_pkgs = module.params['include_packages']
    facts = dicttree()

    facts['_version'] = __version__
    facts['_source'] = __cononical_name__
    facts['subscription_service'] = get_subscription_service()
    facts['package_manager'] = get_package_manager()
    facts['package_format'] = get_package_format()

    try:
        get_packages = getattr(__import__(__name__), 'get_packages_%s' % facts['package_manager'])
        facts['packages_managed'] = get_packages()
    except AttributeError:
        facts['packages_managed'] = {
            'count': -1,
            'repository_list': {}
        }

    try:
        get_raw_packages = getattr(__import__(__name__), 'get_raw_packages_%s' % facts['package_format'])
        facts['packages_raw'] = get_raw_packages()
    except AttributeError:
        facts['packages_raw'] = {
            'count': -1,
            'packages': []
        }

    if options.ansible_called:
        facts = {options.key: facts}
        module.exit_json(changed=False, ansible_facts=facts)
    elif options.shell:
        output_shell(facts)
    elif options.json:
        output_json(facts, options.key)
    elif options.yaml:
        output_yaml(facts, options.key)
    elif options.rhsm:
        output_rhsm(facts, options.key)
    else:
        output_console(facts)

    return os.EX_OK

#==============================================================================
if __name__ == '__main__':
    #-- Setting up logger here so we can use them in even of exceptions.
    #   Parsing options here as we need them to setup the logger.
    options = CLIOptions(sys.argv[1:]) #: pylint: disable=invalid-name
    logger = CLILogger(options.debug)  #: pylint: disable=invalid-name
    if __require_root__ and os.getegid() != 0:
        logger.error('Must be run as root.')
        sys.exit(77)

    #-- NOTE: "except Exception as variable:" syntax was added in 2.6, previously
    #         one would use "except Exception, variable:", but that is not
    #         compatible with 3.x. In order to be compatible with 2.5 (for RHEL 5)
    #         and forward, we use "execpt Exception:", then on the first line of
    #         the exception use "_, error, _ = sys.exc_info()". HOWEVER, pylint
    #         will no longer be able to warn on object members...
    try:
        main()
    except KeyboardInterrupt: # Catches Ctrl-C
        logger.debug('Caught Ctrl-C')
        EXIT_STATUS = 130
    except SystemExit as error: # Catches sys.exit()
        #_, error, _ = sys.exc_info()
        logger.debug('Caught SystemExit')
        logger.warning('%s: [SystemExit] %s', __basename__, error)
        if error.errno is None:
            EXIT_STATUS = 10
        else:
            EXIT_STATUS = error.errno
    except IOError as error:
        #_, error, _ = sys.exc_info()
        logger.debug('Caught IOError')
        if error.errno is None:
            logger.critical('%s: [IOError]: %s', __basename__, error)
            EXIT_STATUS = 10
        elif error.errno == 2:                #: No such file/directory
            logger.critical('%s: [IOError] %s: %s', __basename__,
                            error, error.filename
                           )
            EXIT_STATUS = os.EX_UNAVAILABLE
        elif error.errno == 13:                #: Permission Denied
            logger.critical('%s: [IOError] %s: %s', __basename__,
                            error, error.filename
                           )
            EXIT_STATUS = os.EX_NOPERM
        else:
            logger.critical('%s: [IOError] %s', __basename__, error)
            EXIT_STATUS = error.errno
    except OSError as error:
        #_, error, _ = sys.exc_info()
        logger.debug('Caught OSError')
        if error.errno == 2:                #: No such file/directory
            logger.critical('%s: [OSError] %s: %s', __basename__,
                            error, error.filename
                           )
            EXIT_STATUS = os.EX_UNAVAILABLE
        else:
            logger.critical('%s: [OSError] %s', __basename__, error)
            EXIT_STATUS = error.errno
    except Exception as error: #: pylint: disable=broad-except
        #_, error, _ = sys.exc_info()
        logger.debug('Caught Exception: %s', sys.exc_info())
        logger.critical('%s: %s', __basename__, error)
        EXIT_STATUS = 10
    else:
        logger.debug('main() exited cleanly.')
        EXIT_STATUS = os.EX_OK
    #-- NOTE: "try..except..finally" does not work pre 2.5
    finally:
        logger.debug('Mandatory clean-up.')
        if EXIT_STATUS is None:
            logger.debug('EXIT_STATUS is still None.')
            EXIT_STATUS = 20
        if options.debug:
            print('\n------ end ------\n')
        logging.shutdown()
        sys.exit(EXIT_STATUS)
    #-- NOTE: more exit codes here:
    #--   https://docs.python.org/2/library/os.html#process-management
